# Static Site Boilerplate Template

This is a simple boilerplate for a multi-page static website boilerplate that uses [swup.js](https://swup.js.org/) for seamless page transitions and built using Vite.

Making this public in case anyone would be interested in building their own static site and don't want to use any specific framework. Assuming some poor random soul actually manages to stumble upon this repo, heads up that there's stuff generated by AI in this code, but every line has been reviewed by me. So if anything breaks, that's on me (LOL).

Missing Features:
* Blog _(to be implemented with .md parsing via Marked.js and gray-matter)_
* Simple E-commerce _(Cart and Checkout implementation with Serverless Functions, figure out how to call without placing the links client-side?)_

This project assumes a few things:
* It's a Mac
* `local-build.sh` assumes there's a LimaVM to handle the build process
* Uses specific tools for local dev (npm & Caddy)

## âœ¨ Key Features

The site is built with a "performance-first" architecture that combines the simplicity of static files with the polish of a modern Single Page Application (SPA):

* **SPA-like Navigation (Swup.js)**: Implemented via `app.js`, the site uses **Swup** to handle seamless page transitions without full reloads. The logic is split into a global `main.js` (for persistent elements like the nav) and dynamically imported page scripts (e.g., `home.js`, `about.js`) that are only loaded and initialized when the specific page is viewed.
* **Lazy-Loaded "Hydration"**: Interactive componentsâ€”such as the Instagram feed or About page stat barsâ€”are stored in `js/modules`. Using an `IntersectionObserver` in `main.js`, these modules are strictly **lazy-loaded**; the JavaScript is fetched and executed only when the user scrolls the component into view, keeping the initial page load extremely lightweight.
* **Component-Based Composition**:
  * **HTML**: Uses `vite-plugin-html-inject` to manage reusable partials (Header, Footer, Meta) at build time, keeping the codebase DRY.
  * **CSS**: Styles are modularized. Global styles are shared and imported via `styles.css`, while page-specific CSS is dynamically injected via the meta partial, ensuring the browser only parses styles relevant to the current view.
* **Automated Vite Build Pipeline**: A suite of custom and standard plugins automates the static site generation:
  * **`html-entry-finder`**: Recursively detects all `index.html` files to build the Rollup input options automatically.
  * **`faq-builder-plugin`**: Reads `faq.json` at build time to generate both the user-facing HTML and the SEO JSON-LD Schema, acting as a static "mini-database."
  * **`html-minifier`**: Compresses the final HTML output for production speed.

## ðŸ—ï¸ Development & Deployment

The project has distinct workflows for local testing, live development, and production deployment.

### Getting Started & Environment Variables

To get started, clone the repo, rename it to your site's domain name (example.com), run `init-project.sh` to create the .env files in your root and update the package.json.

Then, you can update the variables in the .env so that it updates for your whole site. Note: The magic keyword for `.env.development` should be the same as the one that you will use for your github secrets.

### Local Build Testing

The `Dockerfile` and `local-build.sh` script are used **exclusively** for testing the production build process locally. This workflow runs within the Lima/nerdctl environment to minify and optimize all assets into a final `dist` directory, simulating the CI/CD build.

Then, the line `caddy file-server --listen :9090` can be run inside the `dist` directory of the lima VM to simulate a live server hosted by CloudFront.

### Local Development Server

For active development with live reloading, run the following command from the project root. This starts the Vite dev server inside a container, with your local files hot-mounted for instant updates.

```bash
nerdctl.lima run --rm -it \
  -p 5173:5173 \
  -v "$(pwd)":/app \
  --workdir /app \
  node:22-alpine \
  sh -c "npm install && npm run dev -- --host"
  ```

For active development with live reloading on a physical mobile device connected via USB C, run the following command:
```bash
npx vite --host
 ```

Here is a clean, copy-pasteable section for your `README.md`. I have separated them into **Secrets** (encrypted) and **Variables** (plaintext), as they are stored in different sections in GitHub.

### Meta-assets

Most of the meta assets for SEO can be generated at [RealFaviconGenerator](https://realfavicongenerator.net/). The other 3 that needs to be created are:
* Logo (logo.png)
* Cover Image (cover-image.png, 1920px x 1080px)
* Socal Share Image (socal-share-image.webp, 1200px x 630px)

### CI/CD Configuration

To successfully run the deployment pipelines, the following **Secrets** and **Variables** must be configured in your GitHub repository settings under **Settings > Secrets and variables > Actions**.

#### Secrets (Encrypted)

| Secret Name | Description | Used In |
| --- | --- | --- |
| `AWS_ACCESS_KEY_ID` | AWS IAM Access Key for deployment. | Dev & Prod |
| `AWS_SECRET_ACCESS_KEY` | AWS IAM Secret Key for deployment. | Dev & Prod |
| `S3_BUCKET_DEV` | Name of the S3 bucket for the **Dev** environment. | Dev Only |
| `S3_BUCKET_PROD` | Name of the S3 bucket for the **Production** environment. | Prod Only |
| `DEV_CLOUDFRONT_DISTRIBUTION_ID` | CloudFront Distribution ID for **Dev** invalidation. | Dev Only |
| `CLOUDFRONT_DISTRIBUTION_ID` | CloudFront Distribution ID for **Production** invalidation. | Prod Only |
| `MAGIC_KEYWORD` | The secret path/subfolder used for Dev deployments. | Dev Only |

#### Variables (Plaintext)

| Variable Name | Value Example | Description |
| --- | --- | --- |
| `AWS_REGION` | `us-east-1` | The AWS Region where your resources reside. |


### Dev Deployment

For internal review, the development site is deployed to `dev.mysite.com/<magickeyword>/`. This is security via obfuscation, where the site is hidden behind a "magic keyword" path (currently in `.env.development`). This allows trusted individuals to view the live site for feedback while preventing public discovery and search engine indexing.

### Prod Deployment

Deployment to production is fully automated via **GitHub Actions**. The workflow defined in `.github/workflows/deploy.yml` is triggered on every push to the main branch.

This process **does not use the Dockerfile**. Instead, it uses the standard actions/setup-node action to build the project in a clean Ubuntu environment, syncs the dist folder to AWS S3, and creates a CloudFront invalidation to ensure the changes go live immediately.
